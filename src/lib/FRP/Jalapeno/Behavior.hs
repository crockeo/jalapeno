-- | The module containing information on the @'Behavior'@ type.
module FRP.Jalapeno.Behavior ( Time
                             , Behavior (..)
                             , ioBehavior
                             , runBehavior
                             , integralFrom
                             , integral
                             ) where

-------------
-- Imports --
import Prelude hiding ((.), id)
import Control.Monad.IO.Class
import Control.Applicative
import Control.Category
import Control.Arrow
import Data.Monoid

----------
-- Code --

-- | Mapping a function onto a tuple of a value and a functor of that value.
--   Used in the @'Applicative'@ instance a number of times.
mapTuple :: Applicative f => ((a -> b), f (a -> b)) -> (a, f a) -> (b, f b)
mapTuple (fnv, fnb) (av, ab) = (fnv av, fnb <*> ab)

-- | A placeholder for the continuous value of time later to come.
type Time = Double

-- | A continuous behavior along a stream of time.
data Behavior t m i a = BehaviorM (t -> i ->  m (a, Behavior t m i a))
                      | BehaviorP (t -> i ->    (a, Behavior t m i a))

instance Functor m => Functor (Behavior t m i) where
  fmap fn (BehaviorM a) =
    BehaviorM $ \t i ->
      fmap (\(v, b) -> (fn v, fmap fn b)) (a t i)

  fmap fn (BehaviorP a) =
    BehaviorP $ \t i ->
           (\(v, b) -> (fn v, fmap fn b)) (a t i)

instance Applicative m => Applicative (Behavior t m i) where
  pure a = BehaviorP $ \_ _ -> (a, pure a)

  (BehaviorM fn) <*> (BehaviorM a) =
    BehaviorM $ \t i ->
      mapTuple <$> fn t i <*> a t i

  (BehaviorP fn) <*> (BehaviorP a) =
    BehaviorP $ \t i ->
      mapTuple (fn t i) (a t i)

  (BehaviorM fn) <*> (BehaviorP a) =
    BehaviorM $ \t i ->
      mapTuple <$> fn t i <*> pure (a t i)

  (BehaviorP fn) <*> (BehaviorM a) =
    BehaviorM $ \t i ->
      mapTuple <$> pure (fn t i) <*> a t i

instance Monad m => Category (Behavior t m) where
  id =
    BehaviorP $ \t i ->
      (i, id)

  (BehaviorM fn2) . (BehaviorM fn1) =
    BehaviorM $ \t a -> do
      (b, bb) <- fn1 t a
      (c, cb) <- fn2 t b

      return (c, cb . bb)

  (BehaviorP fn2) . (BehaviorP fn1) =
    BehaviorP $ \t a ->
      let (b, bb) = fn1 t a
          (c, cb) = fn2 t b in
        (c, cb . bb)

  (BehaviorM fn2) . (BehaviorP fn1) =
    BehaviorM $ \t a ->
      let (b, bb) = fn1 t a in do
        (c, cb) <- fn2 t b
        return (c, cb . bb)

  (BehaviorP fn2) . (BehaviorM fn1) =
    BehaviorM $ \t a -> do
      (b, bb) <- fn1 t a
      let (c, cb) = fn2 t b in
        return (c, cb . bb)

instance Monad m => Arrow (Behavior t m) where
  arr fn =
    BehaviorP $ \t i ->
      (fn i, arr fn)

  first (BehaviorM fn) = undefined
  first (BehaviorP fn) = undefined

-- | The @'Num'@ instance is really just a bunch of the appropriate function
--   applications to the @'Applicative'@ instance.
instance (Applicative m, Num a) => Num (Behavior t m i a) where
  ba + bb     = (+) <$> ba <*> bb
  ba * bb     = (*) <$> ba <*> bb
  abs b       = abs <$> b
  signum b    = signum <$> b
  fromInteger = pure . fromInteger
  negate b    = negate <$> b

-- | The @'Monoid'@ instance - similar to the @'Num'@ instance is just a lot of
--   function applications to the @'Applicative'@ instance.
instance (Applicative m, Monoid a) => Monoid (Behavior t m i a) where
  mempty = pure mempty

  mappend ba bb = mappend <$> ba <*> bb

-- | Performing some @'IO'@ action and wrapping it inside of a @'Behavior'@.
ioBehavior :: MonadIO m => IO a -> Behavior t m i a
ioBehavior v =
  let b = BehaviorM $ \t i ->
            liftIO v >>= return . flip (,) b in
    b

-- | Running a @'Behavior'@ at a given point in time.
runBehavior :: Applicative m => t -> i -> Behavior t m i a -> m (a, Behavior t m i a)
runBehavior t i b =
  case b of
    (BehaviorM fn) ->        fn t i
    (BehaviorP fn) -> pure $ fn t i

-- | A function to run over tuples generated by @'integralFrom'@
integralTupleFn :: (Applicative m, Fractional t, Real a) => t -> t -> t -> (a, Behavior t m i a) -> (t, Behavior t m i t)
integralTupleFn lv lt t (av, ab) =
  let nv = lv + realToFrac av * (t - lt) in
    (nv, integralFrom nv t ab)

-- | Taking the integral of a given @'Behavior'@ over time, from a starting
--   value and a starting time.
integralFrom :: (Applicative m, Fractional t, Real a) => t -> t -> Behavior t m i a -> Behavior t m i t
integralFrom lv lt (BehaviorM a) = BehaviorM $ \t i -> integralTupleFn lv lt t <$> a t i
integralFrom lv lt (BehaviorP a) = BehaviorP $ \t i -> integralTupleFn lv lt t  $  a t i

-- | Taking the integral of a given @'Behavior'@ over time.
integral :: (Applicative m, Fractional t, Real a) => Behavior t m i a -> Behavior t m i t
integral = integralFrom 0 0
