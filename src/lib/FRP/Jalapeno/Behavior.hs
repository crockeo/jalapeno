-- | The module containing information on the @'Behavior'@ type.
module FRP.Jalapeno.Behavior ( Time
                             , Behavior (..)
                             , ioBehavior
                             , runBehavior
                             , integralFrom
                             , integral
                             ) where

-------------
-- Imports --
import Control.Monad.IO.Class
import Control.Applicative
import Data.Monoid

----------
-- Code --

-- | Mapping a function onto a tuple of a value and a functor of that value.
--   Used in the @'Applicative'@ instance a number of times.
mapTuple :: Applicative f => ((a -> b), f (a -> b)) -> (a, f a) -> (b, f b)
mapTuple (fnv, fnb) (av, ab) = (fnv av, fnb <*> ab)

-- | A placeholder for the continuous value of time later to come.
type Time = Double

-- | A continuous behavior along a stream of time.
data Behavior m a = BehaviorM (Time -> m (a, Behavior m a))
                  | BehaviorP (Time ->   (a, Behavior m a))

instance Functor m => Functor (Behavior m) where
  fmap fn (BehaviorM a) =
    BehaviorM $ \t ->
      fmap (\(v, b) -> (fn v, fmap fn b)) (a t)

  fmap fn (BehaviorP a) =
    BehaviorP $ \t ->
           (\(v, b) -> (fn v, fmap fn b)) (a t)

instance Applicative m => Applicative (Behavior m) where
  pure a = BehaviorP $ \_ -> (a, pure a)

  (BehaviorM fn) <*> (BehaviorM a) =
    BehaviorM $ \t ->
      mapTuple <$> fn t <*> a t

  (BehaviorP fn) <*> (BehaviorP a) =
    BehaviorP $ \t ->
      mapTuple (fn t) (a t)

  (BehaviorM fn) <*> (BehaviorP a) =
    BehaviorM $ \t ->
      mapTuple <$> fn t <*> pure (a t)

  (BehaviorP fn) <*> (BehaviorM a) =
    BehaviorM $ \t ->
      mapTuple <$> pure (fn t) <*> a t

-- | The @'Num'@ instance is really just a bunch of the appropriate function
--   applications to the @'Applicative'@ instance.
instance (Applicative m, Num a) => Num (Behavior m a) where
  ba + bb     = (+) <$> ba <*> bb
  ba * bb     = (*) <$> ba <*> bb
  abs b       = abs <$> b
  signum b    = signum <$> b
  fromInteger = pure . fromInteger
  negate b    = negate <$> b

-- | The @'Monoid'@ instance - similar to the @'Num'@ instance is just a lot of
--   function applications to the @'Applicative'@ instance.
instance (Applicative m, Monoid a) => Monoid (Behavior m a) where
  mempty = pure mempty

  mappend ba bb = mappend <$> ba <*> bb

-- | Performing some @'IO'@ action and wrapping it inside of a @'Behavior'@.
ioBehavior :: MonadIO m => IO a -> Behavior m a
ioBehavior v =
  let b = BehaviorM $ \t ->
            liftIO v >>= return . flip (,) b in
    b

-- | Running a @'Behavior'@ at a given point in time.
runBehavior :: Applicative m => Time -> Behavior m a -> m (a, Behavior m a)
runBehavior t b =
  case b of
    (BehaviorM fn) ->        fn t
    (BehaviorP fn) -> pure $ fn t

-- | A function to run over tuples generated by @'integralFrom'@
integralTupleFn :: (Applicative m, Real a) => Double -> Time -> Time -> (a, Behavior m a) -> (Double, Behavior m Double)
integralTupleFn lv lt t (av, ab) =
  let nv = lv + realToFrac av * (t - lt) in
    (nv, integralFrom nv t ab)

-- | Taking the integral of a given @'Behavior'@ over time, from a starting
--   value and a starting time.
integralFrom :: (Applicative m, Real a) => Double -> Time -> Behavior m a -> Behavior m Double
integralFrom lv lt (BehaviorM a) = BehaviorM $ \t -> integralTupleFn lv lt t <$> a t
integralFrom lv lt (BehaviorP a) = BehaviorP $ \t -> integralTupleFn lv lt t  $  a t

-- | Taking the integral of a given @'Behavior'@ over time.
integral :: (Applicative m, Real a) => Behavior m a -> Behavior m Double
integral = integralFrom 0 0
